"use strict";var mysafe={asym:{},sym:{},enc:{},hash:{},utils:{},scrypt:{},isReady:function(){var a=window.crypto||window.msCrypto;return!!a.subtle},exception:{invalidData:function(a){this.toString=function(){return"invalid data: "+this.message},this.message=a},invalidFormat:function(a){this.toString=function(){return"invalid format: "+this.message},this.message=a},invalidParam:function(a){this.toString=function(){return"invalid parameter: "+this.message},this.message=a}}};"use strict",mysafe.asym.generateECDSA=async function(a="P-521"){var b=await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:a},!0,["sign","verify"]);return b},mysafe.asym.exportPublicKey2Bytes=async function(a){const b=await window.crypto.subtle.exportKey("spki","public"==a.type?a:a.publicKey);return b},mysafe.asym.exportPublicKey2Hex=async function(a){const b=await mysafe.asym.exportPublicKey2Bytes(a),c=mysafe.utils.bytes2Hex(b);return c},mysafe.asym.exportPublicKey2B64=async function(a){const b=await mysafe.asym.exportPublicKey2Bytes(a),c=mysafe.utils.bytes2Base64(b);return c},mysafe.asym.exportPrivateKey2Bytes=async function(a){const b=await window.crypto.subtle.exportKey("pkcs8","private"==a.type?a:a.privateKey);return b},mysafe.asym.exportPrivateKey2Hex=async function(a){const b=await mysafe.asym.exportPrivateKey2Bytes(a),c=mysafe.utils.bytes2Hex(b);return c},mysafe.asym.exportPrivateKey2B64=async function(a){const b=await mysafe.asym.exportPrivateKey2Bytes(a),c=mysafe.utils.bytes2Base64(b);return c},mysafe.asym.importPrivateFromBytes=async function(a,b="P-521"){const c=crypto.subtle.importKey("pkcs8",a,{name:"ECDSA",namedCurve:b},!0,["sign"]);return c},mysafe.asym.importPrivateFromHex=async function(a,b="P-521"){const c=mysafe.utils.hex2Bytes(a),d=mysafe.asym.importPrivateFromBytes(c,b);return d},mysafe.asym.importPrivateFromB64=async function(a,b="P-521"){const c=mysafe.utils.base642Bytes(a),d=mysafe.asym.importPrivateFromBytes(c,b);return d},mysafe.asym.importPublicFromBytes=async function(a,b="P-521"){const c=crypto.subtle.importKey("spki",a,{name:"ECDSA",namedCurve:b},!0,["verify"]);return c},mysafe.asym.importPublicFromHex=async function(a,b="P-521"){const c=mysafe.utils.hex2Bytes(a),d=mysafe.asym.importPublicFromBytes(c,b);return d},mysafe.asym.importPublicFromB64=async function(a,b="P-521"){const c=mysafe.utils.base642Bytes(a),d=mysafe.asym.importPublicFromBytes(c,b);return d},mysafe.asym.importPrivateFromBytesECDH=async function(a,b="P-521"){const c=crypto.subtle.importKey("pkcs8",a,{name:"ECDH",namedCurve:b},!0,["deriveKey","deriveBits"]);return c},mysafe.asym.importPrivateFromHexECDH=async function(a,b="P-521"){const c=mysafe.utils.hex2Bytes(a),d=mysafe.asym.importPrivateFromBytesECDH(c,b);return d},mysafe.asym.importPrivateFromB64ECDH=async function(a,b="P-521"){const c=mysafe.utils.base642Bytes(a),d=mysafe.asym.importPrivateFromBytesECDH(c,b);return d},mysafe.asym.importPublicFromBytesECDH=async function(a,b="P-521"){const c=crypto.subtle.importKey("spki",a,{name:"ECDH",namedCurve:b},!0,[]);return c},mysafe.asym.importPublicFromHexECDH=async function(a,b="P-521"){const c=mysafe.utils.hex2Bytes(a),d=mysafe.asym.importPublicFromBytesECDH(c,b);return d},mysafe.asym.importPublicFromB64ECDH=async function(a,b="P-521"){const c=mysafe.utils.base642Bytes(a),d=mysafe.asym.importPublicFromBytesECDH(c,b);return d},mysafe.asym.privateDSA2ECD=async function(a,b="P-521"){const c=await mysafe.asym.exportPrivateKey2Bytes(a);var d=mysafe.asym.importPrivateFromBytesECDH(c,b);return d},mysafe.asym.publicDSA2ECD=async function(a,b="P-521"){const c=await mysafe.asym.exportPublicKey2Bytes(a);var d=mysafe.asym.importPublicFromBytesECDH(c,b);return d},"use strict",mysafe.hash.sha512=async function(a){const b=await crypto.subtle.digest("SHA-512",a);return b},mysafe.hash.sha256=async function(a){const b=await crypto.subtle.digest("SHA-256",a);return b},mysafe.hash.sha1=async function(a){const b=await crypto.subtle.digest("SHA-1",a);return b},mysafe.hash.hmac=async function(a,b,c){let d={name:"HMAC",hash:c},e=await crypto.subtle.importKey("raw",a,d,!1,["sign","verify"]),f=await crypto.subtle.sign(d.name,e,b);return f},mysafe.hash.hmac512=async function(a,b){return mysafe.hash.hmac(a,b,"SHA-512")},mysafe.hash.hmac256=async function(a,b){return mysafe.hash.hmac(a,b,"SHA-256")},mysafe.hash.hmac1=async function(a,b){return mysafe.hash.hmac(a,b,"SHA-1")},mysafe.hash.hkdfDerivation=async function(a,b,c,d,e){const f=await crypto.subtle.importKey("raw",a,{name:"HKDF"},!1,["deriveKey","deriveBits"]),g=await crypto.subtle.deriveBits({name:"HKDF",info:c,salt:b,hash:e},f,d);return g},mysafe.hash.hkdfSha256=async function(a,b,c,d){return mysafe.hash.hkdfDerivation(a,b,c,d,"SHA-256")},mysafe.hash.hkdfSha512=async function(a,b,c,d){return mysafe.hash.hkdfDerivation(a,b,c,d,"SHA-512")},"use strict",mysafe.enc.getTag=function(a,b){return void 0===b&&(b=16),a.slice(a.byteLength-(b+7>>3))},mysafe.enc.encryptData=async function(a,b,c=12,d="AES-GCM"){const e=window.crypto.getRandomValues(new Uint8Array(c)),f=await window.crypto.subtle.encrypt({name:d,iv:e},a,b),g=new Uint8Array(f),h=new Uint8Array(e.length+g.length);return h.set(e),h.set(g,e.length),h},mysafe.enc.decryptData=async function(a,b,c=12,d="AES-GCM"){try{var e=b.slice(0,c),f=b.slice(c,b.length),g=await window.crypto.subtle.decrypt({name:d,iv:e},a,f)}catch(a){throw new mysafe.exception.invalidData("Unable to decrypt:",a.message)}return g},"use strict",mysafe.utils.ascii2Bytes=function(a){for(var b=[],c=0;c<a.length;++c)b.push(a.charCodeAt(c));return new Uint8Array(b)},mysafe.utils.bytes2Ascii=function(a){return String.fromCharCode.apply(null,new Uint8Array(a))},mysafe.utils.bytes2Hex=function(a){if(!a)return null;a=new Uint8Array(a);for(var b,c=[],d=0;d<a.length;++d)b=a[d].toString(16),2>b.length&&(b="0"+b),c.push(b);return c.join("")},mysafe.utils.hex2Bytes=function(a){if(0!=a.length%2)throw new mysafe.exception.invalidParam("invalid hex");for(var b,c=new Uint8Array(a.length/2),d=0;d<a.length;d+=2){if(b=parseInt(a.substr(d,2),16),isNaN(b))throw new mysafe.exception.invalidParam("invalid hex");c[d/2]=b}return c},mysafe.utils.base642Bytes=function(a){var b=new Uint8Array(0);try{var c=window.atob(a),d=c.length;b=new Uint8Array(d);for(var e=0;e<d;e++)b[e]=c.charCodeAt(e)}catch(a){throw new mysafe.exception.invalidParam("invalid base64")}return b.buffer},mysafe.utils.bytes2Base64=function(a){return btoa(new Uint8Array(a).reduce((a,b)=>(a.push(String.fromCharCode(b)),a),[]).join(""))},mysafe.utils.string2Utf8=function(a){for(var b,c=[],d=0;d<a.length;d++)b=a.charCodeAt(d),128>b?c.push(b):2048>b?c.push(192|b>>6,128|63&b):55296>b||57344<=b?c.push(224|b>>12,128|63&b>>6,128|63&b):(d++,b=65536+((1023&b)<<10|1023&a.charCodeAt(d)),c.push(240|b>>18,128|63&b>>12,128|63&b>>6,128|63&b));return new Uint8Array(c)},mysafe.utils.utf82string=function(a){const b=new Uint8Array(a);for(var c,d,e,f="",g=0;g<b.length;)switch(c=b[g++],c>>4){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:f+=String.fromCharCode(c);break;case 12:case 13:d=b[g++],f+=String.fromCharCode((31&c)<<6|63&d);break;case 14:d=b[g++],e=b[g++],f+=String.fromCharCode((15&c)<<12|(63&d)<<6|(63&e)<<0);}return f},"use strict",mysafe.sym.generateKey=async function(a=256,b="AES-GCM"){return window.crypto.subtle.generateKey({name:b,length:a},!0,["encrypt","decrypt"])},mysafe.sym.generateSalt=function(a=16){var b=new Uint8Array(a);return window.crypto.getRandomValues(b),b},mysafe.sym.deriveKey=async function(a,b,c,d="SHA-512"){const e=new ArrayBuffer(0);var f=await mysafe.hash.hkdfDerivation(a,b,e,c,d);return f},mysafe.sym.exportKeyBytes=async function(a){const b=crypto.subtle.exportKey("raw",a);return b},mysafe.sym.exportKey2Hex=async function(a){const b=await mysafe.sym.exportKeyBytes(a),c=mysafe.utils.bytes2Hex(b);return c},mysafe.sym.exportKey2B64=async function(a){const b=await mysafe.sym.exportKeyBytes(a),c=mysafe.utils.bytes2Base64(b);return c},mysafe.sym.getKeyFromBytes=async function(a,b="AES-GCM"){let c=crypto.subtle.importKey("raw",a,b,!0,["encrypt","decrypt"]);return c},mysafe.sym.getKeyFromHex=async function(a){const b=mysafe.utils.hex2Bytes(a);let c=mysafe.sym.getKeyFromBytes(b);return c},mysafe.sym.getKeyFromB64=async function(a){const b=mysafe.utils.base642Bytes(a);let c=mysafe.sym.getKeyFromBytes(b);return c},mysafe.sym.ecdhDerivation=async function(a,b,c=528,d="P-521"){return window.crypto.subtle.deriveBits({name:"ECDH",namedCurve:d,public:b},a,c)},mysafe.sym.saltedPartyKey=async function(a,b,c,d=256){const e=await mysafe.sym.ecdhDerivation(a,b);var f=await mysafe.hash.hkdfSha512(e,c,new Uint8Array(0),d);return f},mysafe.sym.saltedPartyKeyFromEcdh=async function(a,b,c=256){var d=await mysafe.hash.hkdfSha512(a,b,new Uint8Array(0),c);return d},mysafe.sym.pbkdf2DerivationKey=async function(a,b,c,d="SHA-256",e="AES-GCM",f=256){const g=await window.crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]);var h=window.crypto.subtle.deriveKey({name:"PBKDF2",salt:b,iterations:c,hash:d},g,{name:e,length:f},!0,["encrypt","decrypt"]);return h},mysafe.sym.pbkdf2DerivationBits=async function(a,b,c,d,e="SHA-256"){const f=await window.crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveBits","deriveKey"]),g=await window.crypto.subtle.deriveBits({name:"PBKDF2",salt:b,iterations:c,hash:e},f,d);return g},"use strict",mysafe.scrypt.cpyRegion=function(a,b,c,d){const e=a.length-b;for(var f=0;f<e;f++)c[d+f]=0|a[b+f]},mysafe.scrypt.xorRegion=function(a,b,c,d,e){e=e||a.length-b;for(var f=0;f<e;f++)c[d+f]=0|a[b+f]^c[d+f]},mysafe.scrypt.blockMix=function(a){for(var b=a.slice(-16),c=[],d=a.length/16,e=0;e<d;e++)mysafe.scrypt.xorRegion(a,16*e,b,0,16),mysafe.scrypt.salsa20Word(b,8),0==(1&e)?mysafe.scrypt.cpyRegion(b,0,c,8*e):mysafe.scrypt.cpyRegion(b,0,c,8*(e^1+d));return c},mysafe.scrypt.scryptROMix=function(a,b){for(var c=[],d=a.slice(0),e=0;e<b;e++)c.push(d.slice(0)),d=mysafe.scrypt.blockMix(d);for(e=0;e<b;e++){var f=d[d.length-16]&b-1;mysafe.scrypt.xorRegion(c[f],0,d,0),d=mysafe.scrypt.blockMix(d)}return d},mysafe.scrypt.salsa20Word=function(a,b){for(var c=function(c,a){return c<<a|c>>>32-a},d=a.slice(0),e=b;0<e;e-=2)d[4]^=c(d[0]+d[12],7),d[8]^=c(d[4]+d[0],9),d[12]^=c(d[8]+d[4],13),d[0]^=c(d[12]+d[8],18),d[9]^=c(d[5]+d[1],7),d[13]^=c(d[9]+d[5],9),d[1]^=c(d[13]+d[9],13),d[5]^=c(d[1]+d[13],18),d[14]^=c(d[10]+d[6],7),d[2]^=c(d[14]+d[10],9),d[6]^=c(d[2]+d[14],13),d[10]^=c(d[6]+d[2],18),d[3]^=c(d[15]+d[11],7),d[7]^=c(d[3]+d[15],9),d[11]^=c(d[7]+d[3],13),d[15]^=c(d[11]+d[7],18),d[1]^=c(d[0]+d[3],7),d[2]^=c(d[1]+d[0],9),d[3]^=c(d[2]+d[1],13),d[0]^=c(d[3]+d[2],18),d[6]^=c(d[5]+d[4],7),d[7]^=c(d[6]+d[5],9),d[4]^=c(d[7]+d[6],13),d[5]^=c(d[4]+d[7],18),d[11]^=c(d[10]+d[9],7),d[8]^=c(d[11]+d[10],9),d[9]^=c(d[8]+d[11],13),d[10]^=c(d[9]+d[8],18),d[12]^=c(d[15]+d[14],7),d[13]^=c(d[12]+d[15],9),d[14]^=c(d[13]+d[12],13),d[15]^=c(d[14]+d[13],18);for(e=0;16>e;e++)a[e]=d[e]+a[e]},mysafe.scrypt.scryptBits=async function(a,b,c,d,e,f,g="SHA-256"){const h=await mysafe.sym.pbkdf2DerivationBits(a,b,1,8*(128*e*d),g);for(var j,k=new Uint32Array(h),l=k.length/e,m=0;m<e;m++)j=k.slice(m*l,(m+1)*l),mysafe.scrypt.cpyRegion(mysafe.scrypt.scryptROMix(j,c),0,k,m*l);return mysafe.sym.pbkdf2DerivationBits(a,k,1,f,g)};